C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "12864.h"
   2          #include "delay.h"
   3          #include "read_data.h"
   4          
   5          unsigned char i = 0; //用于循环
   6          unsigned char show_data[11]; 
   7          unsigned char state = 0; // 状态函数
   8          int begin_index = 1; // 单词背诵的起点索引
   9          int word_number = 0; // 所有单词的数目
  10          sbit P31 = P3^1;  // ctrl
  11          int recite_ans_record = 0; // 用位记录背诵情况
  12          unsigned char total_number = 0; // 一次背诵中，总的单词数 以及串口发送过程中的下标计数
  13          bit is_receiving = 0;
  14          unsigned char receivedData = 0;
  15          unsigned char word_lenth_counter = 0;
  16          
  17          // 定义波特率，这里使用9600波特率，晶振频率为11.0592MHz
  18          #define BAUD_RATE 9600
  19          #define FOSC 11059200L
  20          #define TIMER1_RELOAD (65536 - (FOSC / 12 / 16 / BAUD_RATE))
  21          
  22          // 定义配对请求码和允许配对响应码，可自行定义合适的值，这里简单示例
  23          #define PAIR_REQUEST_CODE 0xAE // （发送方的） 配对请求信号
  24          #define WORD_SENDING_FINISH 0xA1
  25          #define FIGHT_END 0xAB // （发送方的）对战结束信号
  26          
  27          #define PAIR_ALLOW_CODE 0xAD // （接收方的） 配对允许信号
  28          #define CALLBACK 0xAC // （接收方）回声信号
  29          #define RECITE_FINISH_right 0xAA  // （接收方的）背诵完成信号,会
  30          #define RECITE_FINISH_wrong 0xAD  // （接收方的）背诵完成信号，不会
  31          
  32          
  33          // 定义最大重发次数
  34          #define MAX_RESEND_TIMES 3
  35          
  36          // 定义定时中断次数计数变量
  37          unsigned int count = 0;
  38          
  39          ////////////////////////////////////////////////////////////////////////////////////////////////
  40          
  41          // 按位修改int
  42          void set_bit(int bit_index, int value) {
  43   1          int mask = 1 << bit_index;  // 掩码，将1左移到对应的位位置
  44   1          if (value == 0) {
  45   2              recite_ans_record &= ~mask;  // 设置为0，使用按位与和取反后的掩码操作
  46   2          } else {
  47   2              recite_ans_record |= mask;  // 1，使用按位或操作
  48   2          }
  49   1      }
  50          
  51          void set_bit_for_fight(int bit_index,unsigned char value){
  52   1        int mask = 1 << bit_index*2; // 掩码，将1左移到对应的位位置
  53   1        if(value==0){
  54   2          // 不会
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 2   

  55   2          recite_ans_record &= ~mask;
  56   2        }else if(value == 1){
  57   2          // 都会，但是对方比自己快
  58   2          recite_ans_record |= mask;
  59   2        }else if(value == 2){
  60   2          // 都会，自己比对方快
  61   2          recite_ans_record &= ~mask;
  62   2        }else if(value == 3){
  63   2          // 只有自己会
  64   2          recite_ans_record |= mask;
  65   2        }
  66   1        mask = mask << 1; // 继续左移
  67   1        if(value==0){
  68   2          // 不会
  69   2          recite_ans_record &= ~mask;
  70   2        }else if(value == 1){
  71   2          // 都会，但是对方比自己快
  72   2          recite_ans_record &= ~mask;
  73   2        }else if(value == 2){
  74   2          // 都会，自己比对方快
  75   2          recite_ans_record |= mask;
  76   2        }else if(value == 3){
  77   2          // 只有自己会
  78   2          recite_ans_record |= mask;
  79   2        }
  80   1      }
  81          
  82          // 读取int的指定bit位
  83          int get_bit(int bit_index) {
  84   1          int mask = 1 << bit_index;  // 创建一个掩码，将1左移到对应的位位置
  85   1          return (recite_ans_record & mask) >> bit_index;  // 使用按位与操作获取指定位的值，然后右移到最低位输出
  86   1      }
  87          
  88          int get_bit_for_fighting(unsigned char bit_index){
  89   1          int mask = 1 << bit_index*2;  // 创建一个掩码，将1左移到对应的位位置
  90   1          if((recite_ans_record & mask) >> bit_index){
  91   2            mask =  mask << 1; // 继续左移
  92   2            if((recite_ans_record & mask) >> bit_index){
  93   3               // 4
  94   3              return 40;
  95   3            }else{
  96   3              // 3
  97   3              return 30;
  98   3            }
  99   2          }else{
 100   2            mask =  mask << 1; // 继续左移
 101   2            if((recite_ans_record & mask) >> bit_index){
 102   3              //2
 103   3              return 20;
 104   3            }else{
 105   3              //1
 106   3              return 10;
 107   3            }
 108   2          }
 109   1      }
 110          
 111          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -/////////
 112          
 113          
 114          void cant_connect(){
 115   1        //显示配对失败
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 3   

 116   1        state = 23;
 117   1        Clear();
 118   1        Display_HZ( 2, 3, 16, 46); 
 119   1        Display_HZ( 2, 3, 32, 43); // 显示配对失败
 120   1        Display_HZ( 2, 3, 48, 18);
 121   1        Display_HZ( 1, 3, 0, 44);
 122   1        Display_HZ( 1, 3, 16,45); 
 123   1        Display_HZ( 1, 3, 32, 46); 
 124   1        Display_HZ(2,6,0,33);
 125   1      }
 126          
 127          void fighting_show(unsigned char* show_data_,unsigned char page){
 128   1        Clear();
 129   1      
 130   1        display_str(show_data_,page);
 131   1      
 132   1        // 显示按钮
 133   1        Display_HZ( 2, 6, 0, 14);
 134   1      
 135   1        Display_HZ( 1, 6, 48, 28);
 136   1      
 137   1        // 显示目前的成绩
 138   1        for(i=0;i<total_number-1;i++){
 139   2          if(i == 9){
 140   3            if(get_bit_for_fighting(i) == 10 || get_bit_for_fighting(i) == 20){
 141   4              // 对了
 142   4              Display_HZ(1,0,48,4);
 143   4            }else{
 144   4              // 错了
 145   4              Display_HZ(1,0,48,50);
 146   4            }
 147   3          }else if(i == 8){
 148   3            if(get_bit_for_fighting(i) == 10 || get_bit_for_fighting(i) == 20){
 149   4              // 对了
 150   4              Display_HZ(2,0,0,4);
 151   4            }else{
 152   4              // 错了
 153   4              Display_HZ(2,0,0,50);
 154   4            }
 155   3          }else if(i>=4){
 156   3            if(get_bit_for_fighting(i) == 10 || get_bit_for_fighting(i) == 20){
 157   4              // 对了
 158   4              Display_HZ(1,4,i*16,4);
 159   4            }else{
 160   4              // 错了
 161   4              Display_HZ(1,4,i*16,50);
 162   4            }
 163   3            
 164   3          }else{
 165   3            if(get_bit_for_fighting(i) == 10 || get_bit_for_fighting(i) == 20){
 166   4              // 对了
 167   4              Display_HZ(2,4,i*16,4);
 168   4            }else{
 169   4              // 错了
 170   4              Display_HZ(2,4,i*16,50);
 171   4            }
 172   3          }
 173   2        }
 174   1      }
 175          
 176          // 定时器T0初始化函数
 177          void Timer0_Init()
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 4   

 178          {
 179   1          TMOD &= 0xF0;  // 先清除T0的控制位，保持T1的设置不变
 180   1          TMOD |= 0x01;  // 设置定时器T0为方式1（16位定时器）
 181   1          TH0 = 0xFC;    // 装入初值，定时1ms（高8位），根据晶振频率计算得出，具体计算过程可参考定时器初值计算方
             -法
 182   1          TL0 = 0x18;    // 装入初值，定时1ms（低8位）
 183   1          ET0 = 1;       // 允许T0中断
 184   1          EA = 1;        // 开总中断
 185   1          TR0 = 1;       // 启动定时器T0
 186   1      }
 187          
 188          void Uart_Init()
 189          {
 190   1          TMOD = 0x20;  // 设置定时器1工作模式为模式2（自动重装初值）
 191   1          TH1 = 0xFD;   // 波特率9600（晶振11.0592MHz时），设置定时器初值
 192   1          TL1 = 0xFD;
 193   1          TR1 = 1;      // 启动定时器1
 194   1      
 195   1          SCON = 0x50;  // 串口工作方式1，允许接收
 196   1          ES = 1;       // 允许串口中断
 197   1          EA = 1;       // 开总中断
 198   1      }
 199          
 200          // 函数用于关闭外部中断4
 201          void close_interrupt4(void)
 202          {
 203   1          IE &= 0xBF;  
 204   1      }
 205          
 206          
 207          void sendByte(unsigned char dat)
 208          {
 209   1          SBUF = dat;  // 将数据写入发送缓冲寄存器，启动发送
 210   1          while (!TI); // 等待发送完成，TI为发送中断标志位，发送完成后由硬件置1
 211   1          TI = 0;      // 软件清0发送中断标志位，为下一次发送做准备
 212   1      }
 213          
 214          
 215          // 发送单词的函数
 216          void send_word(unsigned char* arr)
 217          {   
 218   1          int retry_count = 0;
 219   1          for (i = 0; i < 11; i++) {
 220   2              if (arr[i] == 255) {
 221   3                  // 发送单词传输完成信号
 222   3                  i = 0;
 223   3                  sendByte(WORD_SENDING_FINISH);
 224   3                  break;
 225   3              }
 226   2              sendByte(arr[i]);
 227   2              DelayMs(100);
 228   2          }
 229   1          DelayMs(100);
 230   1          while (retry_count < MAX_RESEND_TIMES) {
 231   2              if (RI) {
 232   3                  RI = 0;
 233   3                  sendByte(SBUF);
 234   3                  if (SBUF == CALLBACK) {  
 235   4                      break;
 236   4                  }
 237   3              }
 238   2              // 等待
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 5   

 239   2              DelayMs(500);
 240   2              retry_count++;
 241   2          }
 242   1          if(retry_count < MAX_RESEND_TIMES){
 243   2            // 传输成功
 244   2            begin_index++;
 245   2            total_number++;
 246   2            if(begin_index>=word_number || total_number > 8){
 247   3              //  到头了，这一次对战结束了
 248   3              sendByte(FIGHT_END);
 249   3              begin_index = 1;
 250   3              total_number = 0;
 251   3              // 开始对战结果的呈现
 252   3              // 计算个人得分：
 253   3              word_number = 0;
 254   3              for(i = 0;i<=7;i++){
 255   4                word_number+=get_bit_for_fighting(i);
 256   4              }
 257   3              word_number /= 10;
 258   3              begin_index = 0;
 259   3              Clear();
 260   3              Display_HZ( 2, 0, 32, 55);
 261   3              Display_HZ( 2, 0, 48,56);
 262   3              Display_HZ( 1, 0, 0, 57);
 263   3              Display_HZ( 1, 0, 16, 58);
 264   3              display_number(word_number,2);
 265   3              Display_HZ( 2, 6, 0,33);  // home
 266   3              state = 40;
 267   3              
 268   3            }
 269   2            // 显示单词
 270   2            if(begin_index) fighting_show(show_data,2);
 271   2            // 接下来就等着答题了
 272   2            if(begin_index) state = 26;
 273   2          }else{
 274   2            // 传输失败
 275   2            cant_connect();
 276   2          }
 277   1      }
 278          
 279          void pairing(){
 280   1          int successful = 0;
 281   1          
 282   1          Display_HZ( 2, 3, 32, 41); // 显示开始请求
 283   1          Display_HZ( 2, 3, 48, 42);
 284   1          Display_HZ( 1, 3, 0, 48);
 285   1          Display_HZ( 1, 3, 16,49);
 286   1          sendByte(PAIR_REQUEST_CODE);
 287   1          DelayMs(500); // 等待0.3秒
 288   1          
 289   1      
 290   1          for(i=3;i>0;i--)
 291   1          {
 292   2              if (RI)
 293   2              {
 294   3                  if (SBUF == PAIR_ALLOW_CODE){
 295   4                      // 收到允许配对响应
 296   4                      RI = 0;
 297   4                      successful = 1;
 298   4                      break;
 299   4                  }
 300   3                  else{
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 6   

 301   4                      // 没有接收到允许配对响应
 302   4                      RI = 0;
 303   4                      DelayMs(300);
 304   4                  }
 305   3                  RI = 0;
 306   3              }
 307   2              DelayMs(300);
 308   2          }
 309   1          if(successful){
 310   2            // 开始对战
 311   2            Display_HZ( 2, 3, 16, 47); 
 312   2            Display_HZ( 2, 3, 32, 41); // 显示开始对战
 313   2            Display_HZ( 2, 3, 48, 42);
 314   2            Display_HZ( 1, 3, 0, 18);
 315   2            Display_HZ( 1, 3, 16,19); 
 316   2            Display_HZ( 1, 3, 32, 47);
 317   2            // 下面要选择单词
 318   2            state = 22;
 319   2            begin_index = 1;
 320   2            Clear();
 321   2            Display_HZ( 2, 0, 0, 20);
 322   2            Display_HZ( 2, 0, 16, 21);
 323   2            Display_HZ( 2, 0, 32, 22);
 324   2            Display_HZ( 2, 0, 48, 23);
 325   2            display_number(begin_index,3);
 326   2            Display_HZ( 2, 6, 0, 14);
 327   2            Display_HZ( 1, 6, 48, 15);
 328   2            Display_HZ(1,6,32,36);
 329   2          }else{
 330   2            cant_connect();
 331   2          }
 332   1      }
 333          
 334          // 接收数组数据（启动接收过程）
 335          void ReceiveArray(int command) {
 336   1          if(command){
 337   2          is_receiving = 1;
 338   2          }else{
 339   2            is_receiving = 0;
 340   2          }
 341   1      }
 342          
 343          // 接收端串口中断服务函数
 344          void UartIsr() interrupt 4 {
 345   1          if (RI) {
 346   2              RI = 0;
 347   2              receivedData = SBUF;
 348   2              if(receivedData == PAIR_REQUEST_CODE){
 349   3                //display_number(10,0);
 350   3                // 允许配对
 351   3                if(state == 0 || state == -1 ){
 352   4                  ReceiveArray(1);
 353   4                  sendByte(PAIR_ALLOW_CODE);  // 允许配对
 354   4                  // 开始对战
 355   4                  recite_ans_record = 0;
 356   4                  total_number = 0;
 357   4                  for(i = 0;i<11;i++){
 358   5                    show_data[i] = 255;
 359   5                  }
 360   4                  state = 25;
 361   4                  Clear();
 362   4                  Display_HZ( 2, 3, 16, 47); 
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 7   

 363   4                  Display_HZ( 2, 3, 32, 41); // 显示开始对战
 364   4                  Display_HZ( 2, 3, 48, 42);
 365   4                  Display_HZ( 1, 3, 0, 18);
 366   4                  Display_HZ( 1, 3, 16,19); 
 367   4                  Display_HZ( 1, 3, 32, 47);
 368   4                }
 369   3              }else if(receivedData == RECITE_FINISH_right){
 370   3                if(state == 26){
 371   4                  
 372   4                  state = 28;
 373   4                  //display_number(28,0);
 374   4                }else if(state == 27){
 375   4                  state = 29;
 376   4                  //display_number(29,0);
 377   4                }else if(state == 32){
 378   4                  //发送方会，对方情况刚得知:会
 379   4                  set_bit_for_fight(total_number,2);
 380   4                  // 开始下个单词
 381   4                  state = 24;
 382   4                  ReceiveArray(0); 
 383   4                  get_word_info(begin_index, show_data);
 384   4                  send_word(show_data);
 385   4                }else if(state == 34){
 386   4                   //接收方会，对方情况刚得知:会
 387   4                  set_bit_for_fight(total_number,2);
 388   4                  state = 25;
 389   4                  ReceiveArray(1); // 等待新的单词的到来
 390   4                }else if(state == 33){
 391   4                  state = 24;
 392   4                  ReceiveArray(0); 
 393   4                  get_word_info(begin_index, show_data);
 394   4                  send_word(show_data);
 395   4                }else{
 396   4                  if(get_bit_for_fighting(total_number) != 10){
 397   5                    set_bit_for_fight(total_number,2);
 398   5                  }
 399   4                }
 400   3                Uart_Init();
 401   3              }else if(receivedData == RECITE_FINISH_wrong){
 402   3                if(state == 26){
 403   4                  state = 30;
 404   4                  //display_number(30,0);
 405   4                }else if(state == 27){
 406   4                  state = 31;
 407   4                  //display_number(31,0);
 408   4                }else if(state == 32){
 409   4                  //发送方会，对方情况刚得知:不会
 410   4                  set_bit_for_fight(total_number,3);
 411   4                  // 开始下个单词
 412   4                  state = 24;
 413   4                  ReceiveArray(0); 
 414   4                  get_word_info(begin_index, show_data);
 415   4                  send_word(show_data);
 416   4                }else if(state == 34){
 417   4                   //接收方会，对方情况刚得知:不会
 418   4                  set_bit_for_fight(total_number,3);
 419   4                  state = 25;
 420   4                  ReceiveArray(1); // 等待新的单词的到来
 421   4                }else if(state == 33){
 422   4                  state = 24;
 423   4                  ReceiveArray(0); 
 424   4                  get_word_info(begin_index, show_data);
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 8   

 425   4                  send_word(show_data);
 426   4                }else{
 427   4                  if(get_bit_for_fighting(total_number) != 10){
 428   5                    set_bit_for_fight(total_number,2);
 429   5                  }
 430   4                }
 431   3                Uart_Init();
 432   3              }else if(receivedData ==  FIGHT_END){
 433   3                
 434   3                Clear();
 435   3                word_number = 0;
 436   3                for(i = 0;i<=7;i++){
 437   4                  word_number+=get_bit_for_fighting(i);
 438   4                }
 439   3                word_number /= 10;
 440   3                begin_index = 0;
 441   3                state = 40;
 442   3                Clear();
 443   3                Display_HZ( 2, 0, 32, 55);
 444   3                Display_HZ( 2, 0, 48,56);
 445   3                Display_HZ( 1, 0, 0, 57);
 446   3                Display_HZ( 1, 0, 16, 58);
 447   3                display_number(word_number,2);
 448   3                Display_HZ( 2, 6, 0,33);  // home
 449   3                
 450   3                
 451   3              }else if(is_receiving && state == 25){
 452   3                  //display_number(is_receiving,0);
 453   3                  if(receivedData == WORD_SENDING_FINISH ||word_lenth_counter>=9 ){
 454   4                    //display_number(77,0);
 455   4                    // 这个单词已经传输完了
 456   4                    is_receiving = 0;
 457   4                    sendByte(CALLBACK);
 458   4                    word_lenth_counter = 0;
 459   4                    // 展示单词t
 460   4                    total_number+=1; //前面加多了，这是补偿，但是到后面也有可能出乱子
 461   4                    fighting_show(show_data,2);
 462   4                    /*
 463   4                    display_number(total_number,0);
 464   4                    DelayMs(1000);
 465   4                    for(i=0;i<total_number-1;i++){
 466   4                      display_number(show_data[i],2);
 467   4                      DelayMs(1000);
 468   4                    }*/
 469   4                    // 进入答题状态
 470   4                    state = 27;
 471   4                    //display_number(1111,0);
 472   4                  }else{
 473   4                    //display_number(22,0);
 474   4                    receivedData-=0x80;
 475   4                    show_data[word_lenth_counter] = receivedData-128;
 476   4                    // display_number(receivedData-128,2);
 477   4                    word_lenth_counter++;
 478   4                  }
 479   3              }
 480   2              
 481   2          }
 482   1      }
 483          
 484          ///////////////////////////////////////////////////////////
 485          
 486          void select_function_interface(int selection){
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 9   

 487   1        Clear();
 488   1        Display_HZ( 2, 0, 0, 9);
 489   1        Display_HZ( 2, 0, 16, 10);
 490   1        Display_HZ( 2, 0, 32, 11);
 491   1        Display_HZ( 2, 0, 48, 12);
 492   1        if(!selection){
 493   2          // 背单词
 494   2          Display_HZ( 2, 3, 32, 13);
 495   2          Display_HZ( 2, 3, 48, 6);
 496   2          Display_HZ( 1, 3, 0, 7);
 497   2          Display_HZ( 1, 3, 16, 8);
 498   2        }else{
 499   2          // 对战
 500   2          Display_HZ( 2, 3, 32, 16);
 501   2          Display_HZ( 2, 3, 48, 18);
 502   2          Display_HZ( 1, 3, 0, 19);
 503   2          Display_HZ( 1, 3, 16,17);
 504   2        }
 505   1        Display_HZ( 2, 6, 0, 14);
 506   1        Display_HZ( 1, 6, 48, 15);
 507   1      }
 508          
 509          void word_begin_selection(int command){
 510   1        if(command == 0){
 511   2          // -
 512   2          if(begin_index-10<=0){
 513   3            begin_index = (word_number/10)*10+1;
 514   3          }else{
 515   3            begin_index-=10;
 516   3          }
 517   2        }else{
 518   2          // +
 519   2          begin_index+=10;
 520   2          if(begin_index>=word_number){
 521   3            begin_index=1;
 522   3          }
 523   2        }
 524   1        Clear();
 525   1        Display_HZ( 2, 0, 0, 20);
 526   1        Display_HZ( 2, 0, 16, 21);
 527   1        Display_HZ( 2, 0, 32, 22);
 528   1        Display_HZ( 2, 0, 48, 23);
 529   1        display_number(begin_index,3);
 530   1        Display_HZ( 2, 6, 0, 14);
 531   1        Display_HZ( 1, 6, 48, 15);
 532   1        Display_HZ(1,6,32,36);
 533   1      }
 534          
 535          void show_recode(){
 536   1        for(i=0;i<total_number;i++){
 537   2          if(i == 9){
 538   3            if(get_bit(i)){
 539   4              // 对了
 540   4              Display_HZ(1,0,48,26);
 541   4            }else{
 542   4              // 错了
 543   4              Display_HZ(1,0,48,27);
 544   4            }
 545   3          }else if(i == 8){
 546   3            if(get_bit(i)){
 547   4              // 对了
 548   4              Display_HZ(2,0,0,26);
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 10  

 549   4            }else{
 550   4              // 错了
 551   4              Display_HZ(2,0,0,27);
 552   4            }
 553   3          }else if(i>=4){
 554   3            if(get_bit(i)){
 555   4              // 对了
 556   4              Display_HZ(1,4,i*16,24);
 557   4            }else{
 558   4              // 错了
 559   4              Display_HZ(1,4,i*16,25);
 560   4            }
 561   3            
 562   3          }else{
 563   3            if(get_bit(i)){
 564   4              // 对了
 565   4              Display_HZ(2,4,i*16,24);
 566   4            }else{
 567   4              // 错了
 568   4              Display_HZ(2,4,i*16,25);
 569   4            }
 570   3          }
 571   2        }
 572   1      }
 573          
 574          void recite_words_showing(int show_ans){
 575   1        Clear();
 576   1        if(show_ans == 1){
 577   2          show_recode();
 578   2        }
 579   1        get_word_info(begin_index,show_data);
 580   1        display_str(show_data,2);
 581   1        Display_HZ(2,6,0,14);
 582   1        Display_HZ(1,6,48,28);
 583   1        Display_HZ(1,6,32,36);
 584   1      }
 585          
 586          void recite_res_showing(){
 587   1        int counter = 0;
 588   1        Clear();
 589   1        show_recode();
 590   1        Display_HZ( 2, 0, 32, 32);
 591   1        Display_HZ( 2, 0, 48, 29);
 592   1        Display_HZ( 1, 0, 0, 30);
 593   1        Display_HZ( 1, 0, 16, 31);
 594   1        for(i=0;i<total_number-1;i++){
 595   2          if(get_bit(i)){
 596   3            counter+=1;
 597   3          }
 598   2        }
 599   1        if(counter == 10){
 600   2          Display_HZ( 2, 2, 48, 34);
 601   2          Display_HZ( 1, 2, 0, 35);
 602   2        }else{
 603   2          display_number(counter,2);
 604   2        }
 605   1        Display_HZ( 2, 6, 0, 33);
 606   1        Display_HZ( 1, 6, 48, 15);
 607   1      }
 608          
 609          // 外部中断0的中断服务函数
 610          void int0_service() interrupt 0
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 11  

 611          {
 612   1        if(state == 0){
 613   2          // 背单词
 614   2          // 进行单词选择
 615   2          // 关闭外部中断4
 616   2          close_interrupt4();
 617   2          state = 10;
 618   2          ReceiveArray(0);
 619   2          Clear();
 620   2          Display_HZ( 2, 0, 0, 20);
 621   2          Display_HZ( 2, 0, 16, 21);
 622   2          Display_HZ( 2, 0, 32, 22);
 623   2          Display_HZ( 2, 0, 48, 23);
 624   2          display_number(begin_index,3);
 625   2          Display_HZ( 2, 6, 0, 14);
 626   2          Display_HZ( 1, 6, 48, 15);
 627   2          Display_HZ(1,6,32,36);
 628   2          
 629   2        }else if(state == -1){
 630   2          // 对战
 631   2          state = 20; // 配对状态
 632   2          ReceiveArray(0);
 633   2          Uart_Init();
 634   2          Clear();
 635   2          recite_ans_record = 0; // 清空记录
 636   2          Display_HZ( 2, 3, 32, 37);
 637   2          Display_HZ( 2, 3, 48, 38);
 638   2          Display_HZ( 1, 3, 0, 39);
 639   2          Display_HZ( 1, 3, 16,40);
 640   2          Display_HZ( 2, 6, 0, 33);
 641   2          Display_HZ( 1, 6, 48, 15);
 642   2        }else if(state == 10){
 643   2          // 背诵起始点确定,进入背诵环节
 644   2          close_interrupt4();
 645   2          state = 11;
 646   2          recite_words_showing(0);
 647   2          begin_index++;
 648   2          total_number++;
 649   2        }else if(state == 11){
 650   2          if(P31 == 0){
 651   3            // 会
 652   3            
 653   3            if(begin_index<word_number && total_number<=10){
 654   4              set_bit(total_number-1,1);
 655   4              // 还没有背完，继续下一个
 656   4              recite_words_showing(1);
 657   4              begin_index++;
 658   4              total_number++;
 659   4              
 660   4            }else{
 661   4              // 进入背诵展示阶段
 662   4              state = 12;
 663   4              recite_res_showing();
 664   4            }
 665   3            // 如果按下ctrl， 那就没有任何响应
 666   3          }
 667   2          
 668   2        }else if(state == 12 || state == 20 || state == 23 || state == 40){
 669   2          // 回到主界面
 670   2          state = 0;
 671   2          ReceiveArray(1);
 672   2          begin_index = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 12  

 673   2          total_number = 0;
 674   2          recite_ans_record = 0;
 675   2          word_number = get_word_count();
 676   2          Uart_Init();
 677   2          select_function_interface(0);
 678   2        }else if(state == 22){
 679   2          // 单词起始点已经选好了，开始正式对战
 680   2          state = 24;
 681   2          total_number = 0;  // 初始化计数
 682   2          recite_ans_record = 0;
 683   2          // 发送第一个单词
 684   2          get_word_info(begin_index,show_data);
 685   2          send_word();
*** WARNING C209 IN LINE 685 OF main.c: '_send_word': too few actual parameters
 686   2        }else if(state == 26){
 687   2          // 发送方会, 而且接收方还没有发送
 688   2          sendByte(RECITE_FINISH_right); //发送会的信号
 689   2          // 发送完之后需要等待对方的汇报
 690   2          set_bit_for_fight(total_number,3); // 先登记上
 691   2          state = 32;
 692   2          //display_number(32,0);
 693   2          
 694   2        }else if(state == 27){
 695   2          // 接收方会 ， 发送方还没有发送
 696   2          sendByte(RECITE_FINISH_right); //发送会的信号
 697   2          //ReceiveArray(1);  // 改的这里
 698   2          state = 34;
 699   2          set_bit_for_fight(total_number,3); // 先登记上
 700   2          //display_number(34,0);
 701   2          
 702   2        }else if(state == 28){
 703   2          // 发送方会, 接收方事先会
 704   2          set_bit_for_fight(total_number,1); 
 705   2          if(state % 2 == 0){
 706   3            // 是发送方,该切换下一个单词了
 707   3            sendByte(RECITE_FINISH_right);
 708   3            DelayMs(300); 
 709   3            state = 24;
 710   3            ReceiveArray(0); 
 711   3            get_word_info(begin_index, show_data);
 712   3            send_word(show_data);
 713   3          }else{
 714   3            state = 25;
 715   3            sendByte(RECITE_FINISH_right); //发送会的信号
 716   3            ReceiveArray(1); 
 717   3          }
 718   2          
 719   2        }else if(state == 29){
 720   2          // 接收方会，发送方事先会
 721   2          set_bit_for_fight(total_number,1); 
 722   2          if(state % 2 == 0){
 723   3            // 是发送方,该切换下一个单词了
 724   3            sendByte(RECITE_FINISH_right);
 725   3            DelayMs(300); 
 726   3            state = 24;
 727   3            ReceiveArray(0); 
 728   3            get_word_info(begin_index, show_data);
 729   3            send_word(show_data);
 730   3          }else{
 731   3            state = 25;
 732   3            sendByte(RECITE_FINISH_right); //发送会的信号
 733   3            ReceiveArray(1); 
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 13  

 734   3          }
 735   2          
 736   2        }else if(state == 30){
 737   2          // 发送方会, 接收方不会
 738   2          set_bit_for_fight(total_number,3); 
 739   2          if(state % 2 == 0){
 740   3            // 是发送方,该切换下一个单词了
 741   3            DelayMs(300); 
 742   3            state = 24;
 743   3            ReceiveArray(0); 
 744   3            get_word_info(begin_index, show_data);
 745   3            send_word(show_data);
 746   3          }else{
 747   3            state = 25;
 748   3            sendByte(RECITE_FINISH_right); //发送会的信号
 749   3            ReceiveArray(1); 
 750   3          }
 751   2        }else if(state == 31){
 752   2          // 接收方会，发送方不会
 753   2          set_bit_for_fight(total_number,3); 
 754   2          if(state % 2 == 0){
 755   3            // 是发送方,该切换下一个单词了
 756   3            sendByte(RECITE_FINISH_right);
 757   3            DelayMs(300); 
 758   3            state = 24;
 759   3            ReceiveArray(0); 
 760   3            get_word_info(begin_index, show_data);
 761   3            send_word(show_data);
 762   3          }else{
 763   3            state = 25;
 764   3            sendByte(RECITE_FINISH_right); //发送会的信号
 765   3            ReceiveArray(1); 
 766   3          }
 767   2          
 768   2        }
 769   1        
 770   1      }
 771          
 772          // 定时器T0中断服务函数
 773          void Timer0_ISR() interrupt 1
 774          {
 775   1          TH0 = 0xFC;    // 重新装入初值，定时1ms（高8位）
 776   1          TL0 = 0x18;    // 重新装入初值，定时1ms（低8位）
 777   1          count++;       // 每进入一次中断，计数变量加1
 778   1      }
 779          
 780          // 外部中断1的中断服务函数
 781          void int1_service() interrupt 2
 782          {
 783   1        if(state == 0 || state == -1){
 784   2          // 模式选择
 785   2          if(state == -1){
 786   3            // 背单词
 787   3            Display_HZ( 2, 3, 32, 13);
 788   3            Display_HZ( 2, 3, 48, 6);
 789   3            Display_HZ( 1, 3, 0, 7);
 790   3            Display_HZ( 1, 3, 16, 8);
 791   3            state = 0;
 792   3            close_interrupt4();
 793   3          }else if(state == 0){
 794   3            // 对战
 795   3            Display_HZ( 2, 3, 32, 16);
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 14  

 796   3            Display_HZ( 2, 3, 48, 18);
 797   3            Display_HZ( 1, 3, 0, 19);
 798   3            Display_HZ( 1, 3, 16,17);
 799   3            state = -1;
 800   3            Uart_Init();
 801   3          }
 802   2        }else if(state == 10 || state == 22){
 803   2          // 背诵起始点选择
 804   2          if(P31==0){word_begin_selection(1);}
 805   2          else{word_begin_selection(0);}
 806   2        }else if(state == 11){
 807   2            if(P31 == 0){
 808   3              // 不会
 809   3              set_bit(total_number-1,0);
 810   3              if(begin_index<word_number && total_number<=10){
 811   4                // 还没有背完，继续下一个
 812   4                recite_words_showing(1);
 813   4                begin_index++;
 814   4                total_number++;
 815   4                
 816   4              }else{
 817   4                // 进入背诵展示阶段
 818   4                state = 12;
 819   4                recite_res_showing();
 820   4              }
 821   3            }else if(P31 == 1){
 822   3              // 按下了ctrl，应该进行回滚
 823   3              if(total_number-1 > 0){
 824   4                begin_index--;
 825   4                total_number--;
 826   4                recite_words_showing(1);
 827   4              }
 828   3            }
 829   2          
 830   2        }else if(state == 12){
 831   2          // 开始下一轮背诵
 832   2          begin_index -= 1;
 833   2          total_number = 0;
 834   2          recite_ans_record = 0;
 835   2          state = 10;
 836   2          Clear();
 837   2          Display_HZ( 2, 0, 0, 20);
 838   2          Display_HZ( 2, 0, 16, 21);
 839   2          Display_HZ( 2, 0, 32, 22);
 840   2          Display_HZ( 2, 0, 48, 23);
 841   2          display_number(begin_index,3);
 842   2          Display_HZ( 2, 6, 0, 14);
 843   2          Display_HZ( 1, 6, 48, 15);
 844   2        }else if(state == 20){
 845   2          // 现在连线好了，要开始配对了
 846   2          Display_HZ( 2, 3, 32, 41); // 显示开始配对
 847   2          Display_HZ( 2, 3, 48, 42);
 848   2          Display_HZ( 1, 3, 0, 43);
 849   2          Display_HZ( 1, 3, 16,18);
 850   2          state = 21;
 851   2          pairing();
 852   2        }else if(state == 26){
 853   2          // 发送方不会, 而且接收方还没有发送
 854   2          sendByte(RECITE_FINISH_wrong); //发送不会的信号
 855   2          // 发送完之后需要等待对方的汇报
 856   2          set_bit_for_fight(total_number,0); // 先登记上,反正已经放弃了
 857   2          state = 33; // 发送方不会，对方不知道
C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 15  

 858   2        }else if(state == 27){
 859   2          // 老老实实等发送方的单词信息
 860   2          sendByte(RECITE_FINISH_wrong); //发送不会的信号
 861   2          set_bit_for_fight(total_number,0);
 862   2          state = 25;
 863   2          ReceiveArray(1); // 等待新的单词的到来
 864   2          
 865   2        }else if(state>=28 && state <= 31){
 866   2          // 接收方不会 ， 发送方已经做完了
 867   2          sendByte(RECITE_FINISH_wrong); //发送不会的信号
 868   2          set_bit_for_fight(total_number,0); // 先登记上,这个单词已经放弃了
 869   2          if(state % 2 == 0){
 870   3            // 是发送方,该切换下一个单词了
 871   3            state = 24;
 872   3            get_word_info(begin_index, show_data);
 873   3            send_word(show_data);
 874   3          }else{
 875   3            state = 25;
 876   3          }
 877   2        }
 878   1      
 879   1      }
 880          
 881          void main(){
 882   1          // 外部中断0初始化，设置为下降沿触发
 883   1          IT0 = 1;
 884   1          EX0 = 1;
 885   1          // 外部中断1初始化，设置为下降沿触发
 886   1          IT1 = 1;
 887   1          EX1 = 1;
 888   1          // 打开总中断允许位
 889   1          EA = 1;
 890   1          // 初始化显示数据
 891   1          for(i = 0;i<11;i++){
 892   2            show_data[i] = 255;
 893   2          }
 894   1          word_number = get_word_count();
 895   1          
 896   1          
 897   1          //下面开始进入主界面
 898   1          Clear();
 899   1          Display_HZ( 2, 3, 16, 4);
 900   1          Display_HZ( 2, 3, 32, 0);
 901   1          Display_HZ( 2, 3, 48, 1);
 902   1          Display_HZ( 1, 3, 0, 2);
 903   1          Display_HZ( 1, 3, 16, 3);
 904   1          Display_HZ( 1, 3, 32, 4);
 905   1          DelayMs(1000);
 906   1          //这里应该再加上初始化端口
 907   1          Timer0_Init();
 908   1          Uart_Init();
 909   1          // 下面进入主页面
 910   1          state = 0;
 911   1          select_function_interface(0);
 912   1          
 913   1          
 914   1        while(1){
 915   2      
 916   2        }
 917   1        
 918   1      }

C51 COMPILER V9.60.7.0   MAIN                                                              01/13/2025 08:09:48 PAGE 16  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4271    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
